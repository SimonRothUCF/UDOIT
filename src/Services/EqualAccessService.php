<?php

namespace App\Services;

use App\Entity\ContentItem;
use CidiLabs\PhpAlly\PhpAllyIssue;
use CidiLabs\PhpAlly\PhpAllyReport;
use App\Services\AwsApiAccessibilityService;

use DOMDocument;
use DOMElement;
use DOMXPath;

/*
    Given a JSON report generated by accessibility-checker,
    parse the JSON for all failed rules (according to Equal Access)
    and put them in a phpAlly report

    TODO:
        - check for phpally-ignore on html snippets and ignore them
        - think about how to migrate old database data to equal access
        - find way to skip rules in aws perhaps(?)
*/

class EqualAccessService {

    // probably should disable rules in equal access itself, this is temporary hopefully
    private $skipRules = array(
        "html_lang_exists",
        "html_skipnav_exists",
        "page_title_exists",
        "skip_main_exists",
        "style_highcontrast_visible",
        "style_viewport_resizable",
        "aria_accessiblename_exists",
        "aria_content_in_landmark",
    );

    public function logToServer(string $message) {
        $options = [
            'http' => [
                'header' => "Content-type: text/html\r\n",
                'method' => 'POST',
                'content' => $message,
            ],
        ];
        
        $context = stream_context_create($options);
        file_get_contents("http://host.docker.internal:3000/log", false, $context);
    }

    public function xpathToSnippet($domXPath, $xpathQuery) {
        // Query the document and save the results into an array
        // In a perfect world this array should only have one element
        $xpathResults = $domXPath->query($xpathQuery);
        $htmlSnippet = null;

        // TODO: For now, if there are multiple results we're just
        // going to choose the "last" one
        if (!is_null($xpathResults)) {
            foreach ($xpathResults as $xpathResult) {
                $htmlSnippet = $xpathResult;
            }
        }

        // If no results are found, return null (meaning nothing was found)
        return $htmlSnippet;
    }

    public function checkforIgnoreClass($htmlSnippet) {
        // Assume no phpAllyIgnore by default
        $phpAllyIgnore = false;

        if ($htmlSnippet) {
            $classes = $htmlSnippet->getAttribute("class");

            if (strlen($classes) > 0 && str_contains($classes, "phpally-ignore")) {
                $phpAllyIgnore = true;
            } 
        }

        return $phpAllyIgnore;
    }

    // Generate a UDOIT-style JSON report from the output of Equal Access
    public function generateReport($json, $document) {
        $report = new PhpAllyReport();
        $xpath = new DOMXPath($document);

        $issues = array();
        $issueCounts = array();

        foreach ($json["results"] as $results) {
            $udoitRule = $results["ruleId"];
            $xpathQuery = $results["path"]["dom"];
            $issueHtml = $this->xpathToSnippet($xpath, $xpathQuery);

            // First check if the HTML has phpally-ignore and also check if the rule isn't one we skip.
            if (!$this->checkforIgnoreClass($issueHtml) && !in_array($udoitRule, $this->skipRules)) {
                // Populate the issue counts field with how many total issues
                // with the specific rule are found
                if(array_key_exists($udoitRule, $issueCounts)) {
                    $issueCounts[$udoitRule]++;
                }
                else {
                    $issueCounts[$udoitRule] = 1;
                }

                // Check for null (aka no XPath result was found) and skip.
                // Otherwise, create a new issue with the HTML from the XPath query.
                if (!is_null($issueHtml)) {
                    // UDOIT database has 'html' and 'preview_html',
                    // where 'preview_html' is the parent of the offending html
                    $parentIssueHtml = $issueHtml->parentNode;
    
                    $issue = new PhpAllyIssue($udoitRule, $issueHtml, $parentIssueHtml, null);
                    $report->setIssueCounts($udoitRule, $issueCounts[$udoitRule], -1);
                    array_push($issues, $issue);
                    $report->setErrors([]);
                }
            }
        }

        $report->setIssues($issues);

        // Debug
        $this->logToServer("Generated report! Sending back to ScannerService...");
        // $this->logToServer(json_encode($report, JSON_PRETTY_PRINT));

        return $report;

    }

    public function getDomDocument($html)
    {
        $dom = new DOMDocument('1.0', 'utf-8');
        libxml_use_internal_errors(true);
        if (strpos($html, '<?xml encoding="utf-8"') !== false) {
            $dom->loadHTML("<html><body>{$html}</body></html>", LIBXML_HTML_NOIMPLIED | LIBXML_HTML_NODEFDTD);
        } else {
            $dom->loadHTML("<?xml encoding=\"utf-8\" ?><html><body>{$html}</body></html>", LIBXML_HTML_NOIMPLIED | LIBXML_HTML_NODEFDTD);
        }

        return $dom;

    }
}
